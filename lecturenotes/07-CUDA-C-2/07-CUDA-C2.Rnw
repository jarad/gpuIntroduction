\documentclass{article}

\hoffset = 0pt
\voffset = 0pt
\footskip = 75pt

\usepackage[landscape]{geometry}
\usepackage{amssymb,amsfonts}
\usepackage[all,arc]{xy}
\usepackage{enumerate}
\usepackage{mathrsfs}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{mathrsfs}
\usepackage[all,arc]{xy}
\usepackage{enumerate}
\usepackage{color}
\usepackage{graphicx}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{multirow}
\usepackage{subfig}
\usepackage{color}
\usepackage{Sweave}
\usepackage{SASnRdisplay}

\providecommand{\beq}{\begin{equation*}}
\providecommand{\eeq}{\end{equation*}}
\providecommand{\bs}{\backslash}
\providecommand{\e}{\varepsilon}
\providecommand{\E}{\ \exists \ }
\providecommand{\all}{\ \forall \ }
\providecommand{\Rt}{\Rightarrow}
\providecommand{\rt}{\rightarrow}
\providecommand{\vc}[1]{\boldsymbol{#1}}
\providecommand{\N}{\mathbb{N}}
\providecommand{\Q}{\mathbb{Q}}
\providecommand{\R}{\mathbb{R}}
\providecommand{\C}{\mathbb{C}}
\providecommand{\Z}{\mathbb{Z}}
\providecommand{\Qn}{\mathbb{Q}^n}
\providecommand{\Rn}{\mathbb{R}^n}
\providecommand{\Cn}{\mathbb{C}^n}
\providecommand{\Zn}{\mathbb{Z}^n}
\providecommand{\Qk}{\mathbb{Q}^k}
\providecommand{\Rk}{\mathbb{R}^k}
\providecommand{\Ck}{\mathbb{C}^k}
\providecommand{\Zk}{\mathbb{Z}^k}
\providecommand{\ov}[1]{\overline{#1}}
\providecommand{\lmu}[1]{\lim_{#1 \rightarrow \infty}}
\providecommand{\lmd}[1]{\lim_{#1 \rightarrow -\infty}}
\providecommand{\lm}[2]{\lim_{#1 \rightarrow #2}}
\providecommand{\nv}{{}^{-1}}
\providecommand{\aut}[1]{\text{Aut}{ \ #1}}
\providecommand{\inn}[1]{\text{Inn}{ \ #1}}
\providecommand{\cj}[1]{\overline{#1}}
\providecommand{\wh}[1]{\widehat{#1}}

\newtheorem{thm}{Theorem}[section]
\newtheorem{cor}[thm]{Corollary}
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{conj}[thm]{Conjecture}
\newtheorem{quest}[thm]{Question}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{defns}[thm]{Definitions}
\newtheorem{con}[thm]{Construction}
\newtheorem{exmp}[thm]{Example}
\newtheorem{exmps}[thm]{Examples}
\newtheorem{notn}[thm]{Notation}

\newtheorem{notns}[thm]{Notations}
\newtheorem{addm}[thm]{Addendum}
\newtheorem{exer}[thm]{Exercise}

\theoremstyle{remark}
\newtheorem{rem}[thm]{Remark}
\newtheorem{rems}[thm]{Remarks}
\newtheorem{warn}[thm]{Warning}
\newtheorem{sch}[thm]{Scholium}

\makeatletter
\let\c@equation\c@thm
\makeatother
\numberwithin{equation}{section}

\bibliographystyle{plain}

\providecommand{\pset}{1}   %PUT PROBLEM SET NUMBRER HERE
\renewcommand{\labelenumi}{\alph{enumi}.} %controls enumerating style
\renewcommand{\labelenumii}{\roman{enumii}.} 
  
\setcounter{section}{\pset}

\begin{document}
\begin{flushleft}

\Huge
\begin{center}
$\quad$ \newline
$\quad$ \newline
$\quad$ \newline
$\quad$ \newline
{\bf CUDA C: THE SIMD PARADIGM, SHARED MEMORY, AND THE DOT PRODUCT}
\end{center} $\quad$ \newline

\LARGE

\begin{center}
Will Landau, Prof. Jarad Niemi
\end{center}

\newpage

\Huge
\begin{center}
{\bf OUTLINE} 
\end{center} $\quad$ \newline \Large
\begin{itemize}
\item Respecting the SIMD paradigm
\item Shared memory
\item Implementing the dot product
\end{itemize} $\quad$ \newline

Featured examples: \newline
\begin{itemize}
\item {\tt dot\_product.cu}
\end{itemize}

\newpage




\Huge
\begin{center}
{\bf THE SIMD PARADIGM}
\end{center} $\quad$ \newline

{\bf SIMD}: Single Instruction Multiple Data \newline

Each thread uses the same code, but applies it to different data.  \newline

Try to respect this paradigm in you code. If multiple threads access the same data, problems could arise.



\newpage
\Huge
\begin{center}
{\bf EXAMPLE}
\end{center} 

 \LARGE
Let's say we have a kernel: \newline

\begin{verbatim}
    __global__ void kernel(void){
      int x = blockIdx.x;
    }
\end{verbatim} $\quad$ \newline
\setkeys{Gin}{width=.5\textwidth} \includegraphics[scale=0.25,angle=0]{share} \newline

What will be the final value of x?

\newpage

\huge

All the threads in the grid share the same copy of {\tt a} in {\color{blue} GLOBAL MEMORY}.
\newline

Hence, the final value of {\tt x} is the block ID of the thread that finishes last.





\newpage
\Huge
\begin{center}
{\bf GLOBAL VS SHARED MEMORY}
\end{center} 
\setkeys{Gin}{width=0.7\textwidth} \includegraphics[scale=0.25,angle=0]{mem} \newline
\huge

Why not give each block its own private copy of {\tt x} in shared memory? 
\newpage
\Large
If we define: \newline

\begin{verbatim}
    __global__ void kernel(void){
      __shared__ int x = blockIdx.x;
    }
\end{verbatim} $\quad$ \newline

then each BLOCK will have its own copy of x in {\color{blue} SHARED MEMORY}, shared by all the threads in the block.  \newline \newline

If we call: \newline

\begin{verbatim}
    kernel<<6, 1>>();
\end{verbatim} $\quad$ \newline

Then the final values of $x$ will ALWAYS be: \newline

\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
 &  Block 0 & Block 1 & Block 2 & Block 3 & Block 4 & Block 5 \\ \hline
Thread 0 & x = 0 & x = 1 & x = 2 & x = 3 & x = 4 & x = 5 \\ \hline
\end{tabular} $\quad$ \newline \newline

\newpage

\huge
\begin{center}
{\bf NOW, WE'RE READY FOR THE DOT PRODUCT}
\end{center} $\quad$ \newline

\begin{align*}
(x_1, \ x_2, \ x_3,\  x_4) \bullet (y_1, \ y_2, \ y_3, \ y_4) = x_1 y_1 + x_2 y_2 + x_3 y_3 + x_4 y_4
\end{align*} $\quad$ \newline


\newpage

First part of the code: \newline

\setkeys{Gin}{width=.73\textwidth} \includegraphics[scale=0.25,angle=0]{c1} 
\setkeys{Gin}{width=.47\textwidth} \includegraphics[scale=0.25,angle=0]{c2} \newpage

What the code does: \newline \newline \newline

\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w0} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w1} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w2} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w3} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w4} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w5} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w6} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w7} \newpage
\setkeys{Gin}{width=1.15\textwidth} \includegraphics[scale=0.25,angle=0]{w8} \newpage


We want to make sure that {\tt cache} is filled up for each block before we continue further. \newline

Hence, the next line of code is: \newline \newline

\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{synch} 

\newpage

\Huge
\begin{center}
{\bf NEXT, WE EXECUTE A PAIRWISE SUM ON {\tt cache} FOR EACH BLOCK}
\end{center} $\quad$ \newline

\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{step2} \newpage



\Huge
\begin{center}
{\bf WHAT'S GOING ON}
\end{center} $\quad$ \newline


\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s1} \newpage
\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s2} \newpage
\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s3} \newpage
\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s4} \newpage
\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s5} \newpage
\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{s6} 

Similarly, the contribution of block 1 to the dot product is 183.

Next: \newline

\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{mess} \newline


So now, c[0] = 123 and c[1] is 183. \newline

We return c to the cpu, call it {\tt partial\_c} and then take a linear sum of the elements of {\tt partial\_c}: \newline

\setkeys{Gin}{width=1.1\textwidth} \includegraphics[scale=0.25,angle=0]{final} \newline



Now, c is the final answer.

\newpage

\Huge
\begin{center}
{\bf COMPLETE CODE}
\end{center}



\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp1} \newpage
\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp2} \newpage
\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp3} \newpage
\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp4} \newpage
\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp5} \newpage
\setkeys{Gin}{width=.9\textwidth} \includegraphics[scale=0.25,angle=0]{comp6} \newpage

\newpage

\Huge
\begin{center}
{\bf OUTLINE} 
\end{center} $\quad$ \newline \Large
\begin{itemize}
\item Respecting the SIMD paradigm
\item Shared memory
\item Implementing the dot product
\end{itemize} $\quad$ \newline

Featured examples: \newline
\begin{itemize}
\item {\tt dot\_product.cu}
\end{itemize}

\newpage

\Huge
\begin{center}
{\bf LECTURE SERIES MATERIALS}
\end{center} $\quad$ \newline
\huge
These lecture slides, a tentative syllabus for the whole lecture series, and code are available at: \newline

\begin{center}
 https://github.com/wlandau/gpu. 
\end{center} $\quad$ \newline


After logging into you home directory on impact1, type: \newline

\begin{verbatim}
        git clone https://github.com/wlandau/gpu
\end{verbatim} $\quad$ \newline

into the command line to download all the course materials.


\newpage
\Huge
\begin{center}
{\bf REFERENCES}
\end{center} $\quad$ \newline

David B. Kirk and Wen-mei W. Hwu. ``Programming Massively Parallel Processors: a Hands-on Approach." Morgan Kaufman, 2010. \newline

J. Sanders and E. Kandrot. {\it CUDA by Example}. Addison-Wesley, 2010. \newline

Michael Romero and Rodrigo Urra. "CUDA Programming."  Rochester Institute of Technology. http://cuda.ce.rit.edu/cuda\_overview/cuda\_overview.html

\end{flushleft}
\end{document}

